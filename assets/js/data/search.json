[ { "title": "Markdown Sytax Tutorials", "url": "/posts/Markdown-Tutorials/", "categories": "Tools, Markdown", "tags": "markdown", "date": "2021-11-01 16:48:58 +0800", "snippet": "这是一级标题# 这是一级标题这是二级标题## 这是二级标题换行用空格+enter或者&amp;lt;br&amp;gt; 强调hhh**hhh**hhh*hhh*[[hehehe]][[hehehe]] My Great Heading### My Great Heading {#custom-id}公式$$\\lim_{x \\to \\infty} \\frac{sin(t)}{x}=1$$\\[\\lim_{x \\to \\infty} \\frac{sin(t)}{x}=1\\]在vscode中连续按两下ctrl+m会产生四个$，来编辑公式。如果要在一段文字中插入公式（行内），用快捷键ctr+m或输入:$\\lim_{x \\to \\infty} \\frac{sin(t)}{x}=1$$\\lim_{x \\to \\infty} \\frac{sin(t)}{x}=1$ 表格| 小明 | 大明 | 姚明 || :--- | ---: | :---: || 1.3 | 1.2 | 1.8 | 小明 大明 姚明 1.3 1.2 1.8 (按住 alt+shift+f 可以将文本中的表格部分格式化)链接这是一个链接这是一个[链接](https://zh.d2l.ai/)代码块def to_onehot(X, size): # 本函数已保存在d2lzh包中方便以后使用 return [nd.one_hot(x, size) for x in X.T]X = nd.arange(10).reshape((2, 5))inputs = to_onehot(X, vocab_size)len(inputs), inputs[0].shape```pythondef to_onehot(X, size): # 本函数已保存在d2lzh包中方便以后使用 return [nd.one_hot(x, size) for x in X.T]X = nd.arange(10).reshape((2, 5))inputs = to_onehot(X, vocab_size)len(inputs), inputs[0].shape```对号\\(\\checkmark\\huge \\color{red}{\\checkmark}\\)$$\\checkmark\\huge \\color{red}{\\checkmark}$$vscode常用快捷键vscode禅模式快捷键：ctrl+k 松开再按z按两下esc即可退出禅模式KeybindingsThe cmd key for Windows is ctrl. Shortcuts Functionality ctrl-k v Open preview to the Side ctrl-shift-v Open preview ctrl-shift-s Sync preview / Sync source shift-enter Run Code Chunk ctrl-shift-enter Run all Code Chunks cmd-= or cmd-shift-= Preview zoom in cmd– or cmd-shift-_ Preview zoom out cmd-0 Preview reset zoom esc Toggle sidebar TOC Blockquote blockquote&amp;gt;blockquoteOrdered List First item Second item Third item1. First item2. Second item3. Third itemUnordered List First item Second item Third item- First item- Second item- Third itemTask List task1 task2- [x] task1- [ ] task2Definition List term definitionterm: definitionStrikethroughThe world is flat.~~The world is flat.~~Image![](https://zjpzhao.github.io/assets/img/2021-11-01-Markdown-Tutorials/CAAQA.png)![](https://zjpzhao.github.io/assets/img/2021-11-01-Markdown-Tutorials/ML.png)FootnoteHere’s a sentence with a footnote. 1Here&#39;s a sentence with a footnote. [^1][^1]: This is the footnote. This is the footnote. &amp;#8617; " }, { "title": "LeetCode-673. 最长递增子序列的个数", "url": "/posts/673-Number-of-Longest-Increasing-Subsequence/", "categories": "Algorithms, LeetCode", "tags": "贪心, DP, 二分, 前缀和", "date": "2021-09-20 21:00:00 +0800", "snippet": "关联先阅读LeetCode-300. 最长上升子序列，在此基础上进行扩展。此题相当于就是在300题的基础上增加记录历史信息。方法1 DP思考在LeetCode-300. 最长上升子序列的方法一的基础上，增加一个数组$cnt$，$cnt[i]$表示以$num[i]$结尾的最长上升子序列的个数。设$nums$的最长上升子序列的长度为$maxlen$，则对于所有$dp[i]=maxlen$的i，累加对应的$cnt[i]$即可得到答案。代码class Solution {public: int findNumberOfLIS(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int n=nums.size(); if(n==0) return 0; int maxlen=0,ans=0; vector&amp;lt;int&amp;gt; dp(n),cnt(n);//dp记录以nums[i]结尾的最长上升子序列长度，cnt记录以nums[i]结尾的最长上升子序列的个数 for(int i=0;i&amp;lt;n;i++){ dp[i]=1; cnt[i]=1; for(int j=0;j&amp;lt;i;j++){ if(nums[j]&amp;lt;nums[i]){ if(dp[i]&amp;lt;dp[j]+1){ dp[i]=dp[j]+1;//更新了更长的长度，所以同时需要更新该长度的上升子序列个数 cnt[i]=cnt[j];//重新计数，个数从num[i]那里继承过来 } else if(dp[i]==dp[j]+1)//说明同样的长度，也可以从num[j]过来，所以把长度j的个数也加进来 cnt[i]+=cnt[j]; } } //遍历每个数组元素的时候，都记录一下当前最大长度和对应的个数 if(dp[i]&amp;gt;maxlen){ maxlen=dp[i];//更新最大长度 ans=cnt[i];//重新计数 }else if(dp[i]==maxlen){ ans+=cnt[i];//累加计数 } } return ans; }};复杂度分析 时间复杂度：$O(n^2)$ 空间复杂度：$O(n)$方法2 贪心+二分+前缀和思考 同样在LeetCode-300. 最长上升子序列方法二基础上，将数组d扩展成为2维的，不止记录最小末尾元素，一维数组$d[i]$记录：所有能构成长度i的最长上升子序列的末尾元素，即记录的历史信息。具体地，将300题方法二的②中$d[k+1]=nums[i]$换成：将$nums[i]$置于$d[k+1]$数组末尾，$d[i]$是单调非增的。 同样定义一个二维数组$cnt$，$cnt[i][j]$记录以$d[i][j]$为结尾的最长上升子序列个数，计算$cnt[i][j]$就是将所有满足$d[i−1][k]&amp;lt;d[i][j]$的$c[i-1][k]$累加到$cnt[i][j]$，最后答案是$cnt[maxlen]$的所有元素和。 由于$d[i]$是单调非增的。所以可以采用二分法得到上面提到的k。另外，将$cnt$改为前缀和，开头为0，则$d[i][j]$对应的最长上升子序列的个数是$cnt[i-1][-1]-cnt[i-1][k]$（[-1]表示数组最后一个元素） 前缀和原本表示$a[1:n]$如下 1 2 3 … n-1 n $a[1]$ $a[2]$ $a[3]$ … $a[n-1]$ $a[n]$ 表示成前缀和$b[1:i]$如下 1 2 3 … n-1 n $a[1]$ $\\sum_{i=1}^{2} a[i]$ $\\sum_{i=1}^{3} a[i]$ … $\\sum_{i=1}^{n-1} a[i]$ $\\sum_{i=1}^{n} a[i]$ 有$a[i]=b[i]-b[i-1]$，前缀和的好处是在存入的时候就进行累加，最后可以省去最后遍历的次数（求原本表示中$a[k:i]$的元素和需要遍历然后累加，使用前缀和表示后只需要用$b[i]-b[k-1]$即可）代码class Solution { int binarySearch(int n, function&amp;lt;bool(int)&amp;gt; f) { int l = 0, r = n; while (l &amp;lt; r) { int mid = l + ((r - l) &amp;gt;&amp;gt; 2); if (f(mid)) { r = mid; } else { l = mid + 1; } } return l; }public: int findNumberOfLIS(vector&amp;lt;int&amp;gt; &amp;amp;nums) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; d, cnt; for (int v : nums) { int i = binarySearch(d.size(), [&amp;amp;](int i) { return d[i].back() &amp;gt;= v; }); int c = 1; if (i &amp;gt; 0) { int k = binarySearch(d[i - 1].size(), [&amp;amp;](int k) { return d[i - 1][k] &amp;lt; v; }); c = cnt[i - 1].back() - cnt[i - 1][k]; } if (i == d.size()) { d.push_back({v}); cnt.push_back({0, c}); } else { d[i].push_back(v); cnt[i].push_back(cnt[i].back() + c); } } return cnt.back().back(); }};复杂度分析 时间复杂度：$O(n\\log(n))$ 空间复杂度：$O(n)$更多细节参考$LeetCode$官方题解" }, { "title": "LeetCode-300. 最长上升子序列", "url": "/posts/300-Longest-Increasing-Subsequence/", "categories": "Algorithms, LeetCode", "tags": "贪心, DP, 二分", "date": "2021-09-20 21:00:00 +0800", "snippet": "关联LeetCode-673. 最长递增子序列的个数方法1 DP思考$dp[i]$表示前i个元素中，以$num[i]$元素结尾（必选）的最长上升子序列长度，写出下列状态转移方程：\\(dp[i]=max(dp[j])+1,\\ 0\\le j \\lt i,\\ num[j]&amp;lt;num[i].\\)整体的最长上升子序列数量是：$LIS=max{dp[i]},\\ 0\\le i \\lt n.$举例 $nums$ 10 9 2 5 3 7 101 18 $dp$ 1 0 0 0 0 0 0 0 $dp$ 1 1 0 0 0 0 0 0 $dp$ 1 1 1 0 0 0 0 0 $dp$ 1 1 1 2 0 0 0 0 $dp$ 1 1 1 2 2 3 4 4 代码class Solution {public: int lengthOfLIS(vector&amp;lt;int&amp;gt;&amp;amp; nums){ int n=nums.size(); if(n==0) return 0; vector&amp;lt;int&amp;gt; dp(n,0); for(int i=0;i&amp;lt;n;i++){//求dp[i] dp[i]=1; for(int j=0;j&amp;lt;i;j++){ if(nums[j]&amp;lt;nums[i]) dp[i]=max(dp[i],dp[j]+1); } } return *max_element(dp.begin(),dp.end()); }}; 复杂度分析 时间复杂度：$O(n^2)$ 空间复杂度：$O(n)$方法2 贪心+二分思考我们让新添加进来的末尾元素尽可能的小，让上升的幅度小一些，以便得到更长的子序列。所以这里采用一个数组d来记录长度为length的最长上升子序列的最小末尾元素，初始值为$d[1]=nums[0]$，注意是从1开始。因为上升子序列要求严格递增，则数组d也是单调递增的，也就是说越长的上升子序列最小末尾元素也就越大。根据数组d的单调性，我们这里查找可以采用二分法，伪代码如下：遍历$nums$，更新$len$，和数组d，对于$nums[i]$：① 如果$nums[i]&amp;gt;d[len]$，则$d[++len]=nums[i]$② 否则在$d[1:len]$中二分查找：第一个比$nums[i]$小的数$d[k]$，同时$d[k+1]=nums[i]$举例   0 8 4 12 2 $nums[i]$ ①/② d 0         0   d 0 8       8 ① d 0 4       4 ② d 0 4 12     12 ① d 0 2 12     2 ② 代码class Solution {public: int lengthOfLIS(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int n=nums.size(); if(n==0) return 0; int len=1; vector&amp;lt;int&amp;gt; d(n+1,0); d[len]=nums[0]; for(int i=1;i&amp;lt;n;i++){//从nums[1]开始遍历nums if(nums[i]&amp;gt;d[len]) d[++len]=nums[i]; else { int l=1,r=len,pos=0; //注意d是从d[1]开始的；如果找不到说明所有的数都比nums[i]大，此时更新d[1]，所以初始pos设0 while(l&amp;lt;=r){ int mid=((r-l)&amp;gt;&amp;gt;1)+l; if(d[mid]&amp;lt;nums[i]){ pos=mid; l=mid+1; } else r=mid-1; } d[pos+1]=nums[i]; } } return len; }};复杂度分析 时间复杂度：$O(n\\log(n))$ 空间复杂度：$O(n)$更多细节参考$LeetCode$官方题解" }, { "title": "搭建个人博客：Jekyll + Github Pages + VSCode", "url": "/posts/jekyll-githubpages/", "categories": "Tools", "tags": "Jekyll, Blog, vscode", "date": "2021-05-10 16:13:00 +0800", "snippet": "Github Page + Jekyll我选用的是Jekyll主题Chirpy，其效果页面和使用手册在Live Demo，创建该主题的page repo有两种方式： 使用Chripy Starter：非常容易进行主题的版本升级，隔离无关的主题文件项目，仓库比较简洁。 直接在GitHub上Fork该项目：对个性化二次开发友好但是难升级，经过各种折腾后的我个人不推荐使用。下面记录我用第一种方法Starter踩的一些坑： 配置本地环境：参考 Jekyll Docs 安装 Ruby，RubyGems，Jekyll 和 Bundler。 利用该Chripy Starter generate链接生成repo，克隆到本地然后run命令$ bundle。 此过程是通过RubyGems.org上发布的Chirpy主题来进行安装和初始化的，生成的repo会自动隐藏四个文件夹_includes、_layout、_sass和assets，而Jekyll只会读取这四个文件夹的内容和_config.yml文件的一部分。 我开始的时候发现生成的repo东西不全但是deploy的blog看上去大部分是正常的，等到要部署评论模块的时候，发现我需要将scripts添加到文件夹_layouts里的post.html中，但是完全找不到这个文件夹。另外，每篇blog引用的图片都应该存储到本来被隐藏的文件夹assets的img中，所以发布的所有blog引用的图片全失效了。结果我在start overflow这里找到了答案：也就是说：如果在本地已经安装好了这个主题的theme gem（实际上就是通过步骤2中的$ bundle命令完成的），可以用命令bundle info --path jekyll-theme-chirpy查看没有隐藏文件夹的项目是什么样子：最重要的是这四个文件夹是可以overwrite的！！！ 所以我将上图中被隐藏的文件夹复制到我的本地repo中，就可以通过修改它们对该主题进行二次开发了，例如部署下面介绍的utterances。实现gitpage上的评论模块——使用utterances登录官网，按照说明进行配置和选择（千万不要忘记为你的repo安装utterances app）。评论模块的主题这里，我选择可以适应浏览端操作系统亮暗风格的preferred-color-scheme，最后生成如下script代码：&amp;lt;script src=&quot;https://utteranc.es/client.js&quot; repo=&quot;zjpzhao/zjpzhao.github.io&quot; issue-term=&quot;title&quot; label=&quot;Comment&quot; theme=&quot;preferred-color-scheme&quot; crossorigin=&quot;anonymous&quot; async&amp;gt;&amp;lt;/script&amp;gt; 注意repo=”zjpzhao/zjpzhao.github.io”不能带最后的slash（形如：repo=”zjpzhao/zjpzhao.github.io/”）将上面的代码插入到zjpzhao.github.io_layouts\\post.html，push之后就可以在每一篇博客下方找到评论区了，发布的评论会在github项目的Issues中显示。 注意放置的位置和空格缩进，不可以用tab只能用空格缩进插入到post.html中的位置发布的评论在github Issues提醒和显示本地编译在本地根目录执行$ bundle exec jekyll s然后在浏览器中查看http://localhost:4000/其他命令行用法参照https://www.jekyll.com.cn/docs/usage/网页自动生成目录jekyll自动识别二级标题，并生成博客右侧的目录content（注意只能是二级标题！）粘贴图片工具-VSCode插件Paste Image按照配置样例修改settings.json在settings.json中加入&quot;pasteImage.showFilePathConfirmInputBox&quot;: true,&quot;pasteImage.path&quot;: &quot;${projectRoot}/assets/img/${currentFileNameWithoutExt}&quot;,&quot;pasteImage.basePath&quot;: &quot;${projectRoot}&quot;,&quot;pasteImage.forceUnixStyleSeparator&quot;: true,&quot;pasteImage.prefix&quot;: &quot;/&quot;（以上代码参照vscode插件Extension: Paste Image下载处教程）效果如下：保存路径预览保存和生成链接代码注意，直接复制图片文件然后粘贴是不行的，会在右下角报错：报错不识别ERROR原因是:直接复制文件不会进入剪贴板（推测与文件操作用的不是一套剪贴板）解决方法是:打开这张图片然后复制到剪贴板在图片浏览器中复制到剪贴板成功复制到剪贴板" }, { "title": "Common Linux Commands", "url": "/posts/Linux-utils/", "categories": "Linux", "tags": "Ubuntu, Shell, TODO", "date": "2021-05-09 20:19:00 +0800", "snippet": "Understand a Command $ man command for manual pages $ command --help for helpRun at BackgroundThe screen command launches a terminal in the background which can be detached from and then reconnected to. You can start a screen, kick off a command, detach from the screen, and log out. You can then log in later and reattach to the screen and see the program running. startup $ screen -S XXX.py detach Ctrl + a + d reattach $ screen -r from https://access.redhat.com/articles/5247Monitor Resources Network Bandwidth $ nload Other 17 commands：https://www.binarytides.com/linux-commands-monitor-network/ CPU $ top GPU $ nvidia-smi Disk $ du -h $ df -h Continuous Monitoring $ watch -n 0.5 nvidia-smiRename files in batches$ rename [options] &quot;s/oldname/newname/&quot; fileCommand rename’s options and parameters:-n preview result without execute(directly execute if without option [-n])s stands for ‘substitution’[()] Represents matching the content in []// The empty space between the two slashes means replacing the empty content, equivalent to deletingg means all matches, only one bracket will be matched by default if without it^- add characters at the beginning of the file nameOther rules：https://www.cnblogs.com/mianbaoshu/p/11772876.htmlPerl regular expressions：https://perldoc.perl.org/perlre" } ]
